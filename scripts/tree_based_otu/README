To rebuild the tree used for OTU assignment, first obtain a large sequence set
in which to build your tree from. For instance, the Hugenholtz set from
Green Genes. These sequences should be filtered to remove low quality reads,
chimeras, etc. There will most likely be a very large number of sequences 
remaining, as such, it is recommended that FastTree is used for tree 
construction. Then, the tree nodes must be collapsed down at varying 
threshold levels. You can specify existing taxonomy information here if you 
would like to have the OTUs map (were possible) to previously determined
lineages. Once we know our OTUs, we can pick representative sequences from
each cluster. Sequences to classify can then be BLASTed against the 
representative sequences to determine the closest OTU.

filter_seqs.py
    -removes sequences that are <1000nt or have any ambiguous bases
    -test code is within the script

collapse_tree_nodes.py
    -collapses tree nodes based on the average branch length to descending
        tips
    -can specify an existing taxonomy
    -OTU ids that are returned are based off the RangeNode.assignIds() method
    -branch length correction can be applied as well. this correction is used
        to improve the correlation between sequence identity and branch length.
        for the filtered hugenholtz set, a correction of 0.88425503 was used.

representative_sequences.py
    -picks representative sequences for each OTU
    -currently, LongestSequence and RandomSequence are implemented
    -the default tiebreaker method is random

blast_to_otutable.py
    -takes blast results and builds an OTU table
    -the sequence to otu map is the mapping file from representative_sequences
    -the sequence to db map is the mapping file relating input sequences to 
        metadata present in the Microbiome database

cut_off_children.py
    -takes a tree and cuts off children at specified nodes
    -was written to get Rob a tree that had tips as the OTUs
    -currently no tests. just parses an otufile and unsets .Children on the 
        corresponding nodes.

add_on_consensus.py
    -the blast_to_otutable code does not slap on the lineage information
        (if available) currently. this script takes the otu table
        and appends on the lineage information
    -currently no tests, essentially just really really light weight parsers

parse_greengenes_records.py
    -takes the greengenes sequence data mappings from: http://greengenes.lbl.gov/Download/Sequence_Data/Greengenes_format/greengenes16SrRNAgenes.txt.gz
    -spits out a reduced tab delimited file with just the fields we care about

For GreenGenes OTU tree:
1) Download the Hugenholtz set, http://greengenes.lbl.gov/Download/Sequence_Data/Fasta_data_files/current_prokMSA_aligned.fasta.gz

2) Apply Lane mask
    -apply_lanemask.py
    -argv[1] is lanemask
    -argv[2] is alignment
    -output is thrown to stdout (some intermediate file)

3) Run filter_seqs.py on Lane masked alignemnt
    -argv[1] is alignment (intermediate file from step 2)
    -argv[2] is minimum sequence length (gaps do not count)
    -argv[3] is maximum number of non ATGCU.- characters (case is ignored)
    -argv[4] is output file (greengenes_lanemasked_filtered.fasta)

4) Use FastTree to build the tree
    FastTree -nt greengenes_lanemasked_filtered.fasta > \
        greengenes_lanemasked_filtered.ntree

5) Run parse_greengenes_taxonomy.py to produce reduced tab-delim taxonomy file
    -argv[1] is greengenes16SrRNAgenes.txt (see note on script above)
    -argv[2] is output (greengenes_taxonomy_map.txt)

6) Run collapse_taxontree_nodes.py on the tree
    -specify --taxonomy-file=greengenes_taxonomy_map.txt (from step 5)
    -specify --tree-file=greengenes_lanemasked_filtered.ntree
    -specify --start-range=0.01 (starting OTU threshold level)
    -specify --end-range=0.15 (ending OTU threshold level)
    -specify --step-size (OTU threshold step size)
    -specify --branch-length-correction (see note on script above)
    -output is to stdout (greengenes_lanemasked_filtered.otus)
        -fields: OTU\tNCBI Taxon ID\tThreshold level

7) Run representative_sequences.py
    -specify --fasta-file=greengenes_lanemasked_filtered.fasta
    -specify --tree-file=greengenes_lanemasked_filtered.ntree
    -specify --otu-file=greengenes_lanemasked_filtered.otus
    -specify --degap to degap result sequences
    -will produce a fasta file and map for each threshold level
        -ex: greengenes_lanemasked_filtered.fasta.OTUs_at_0.01.fasta and
             greengenes_lanemasked_filtered.fasta.OTUs_at_0.01.map
        -map is: OTU -> sequence ID

8) Split up input data, build blastdb and blast
    -use Rob's parallel_blast.py script
    -specify input sequences to classify
    -specify greengenes_lanemasked_filtered.fasta.OTUs_at_0.01.fasta for db

9) Run blast_to_otutable.py
    -specify --blast-results-path=the results path from step 8
    -specify --sequence-to-otu-map=\
                  greengenes_lanemasked_filtered.fasta.OTUs_at_0.01.map
    -specify --sequence-to-db-map=the mapping file that relates the input
        sequences (seqs that were blasted) to the microbiome database
        -expects seqid\tstudy_name\tsampleid\tignored
    -output is greengenes_lanemasked_filtered.fasta-OTUs_at_0.01.fasta.otutable

10) Run add_on_consensus.py (should be merged into blast_to_otutable.py)
    -argv[1] is greengenes_taxonomy_map.txt (from step 5)
    -argv[2] is greengenes_lanemasked_filtered.otus (from step 6)
    -argv[3] is greengenes_lanemasked_filtered.fasta-OTUs_at_0.01.fasta.otutable
    -output is argv[3] + '-with_lineage.txt'

11) Run cut_off_children.py
    -argv[1] is greengenes_lanemasked_filtered.ntree
    -argv[2] is greengenes_lanemasked_filtered.otus
    -output is argv[1] + '-otus_at_tips.ntree'
